"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const xml2js_1 = require("xml2js");
const progress_publisher_1 = require("./progress-publisher");
const handler = async (event) => {
    const startTime = Date.now();
    console.log('Parsing sitemap for URL:', event.url);
    // Initialize progress publisher and S3 client
    const progress = new progress_publisher_1.ProgressPublisher(event.sessionId);
    const s3Client = new client_s3_1.S3Client({ region: process.env.AWS_REGION });
    try {
        // Send initial progress
        await progress.progress('Starting sitemap parsing...', 'sitemap-parsing');
        // Fetch and parse the sitemap
        const result = await parseSitemapRecursively(event.url, progress, 0);
        // Store results in S3
        const s3Key = `sessions/${event.sessionId}/sitemap-results.json`;
        const s3Location = `s3://${process.env.ANALYSIS_BUCKET}/${s3Key}`;
        const sitemapResults = {
            originalUrl: event.url,
            totalUrls: result.urls.length,
            urls: result.urls,
            nestedSitemaps: result.nestedSitemaps,
            processingTime: Date.now() - startTime,
            timestamp: new Date().toISOString()
        };
        await s3Client.send(new client_s3_1.PutObjectCommand({
            Bucket: process.env.ANALYSIS_BUCKET,
            Key: s3Key,
            Body: JSON.stringify(sitemapResults, null, 2),
            ContentType: 'application/json'
        }));
        // Send completion message
        await progress.success(`Sitemap parsing complete: Found ${result.urls.length} URLs${result.nestedSitemaps > 0 ? ` (${result.nestedSitemaps} nested sitemaps)` : ''}`, {
            totalUrls: result.urls.length,
            nestedSitemaps: result.nestedSitemaps,
            processingTime: Date.now() - startTime
        });
        console.log(`Sitemap parsing completed: ${result.urls.length} URLs found`);
        return {
            success: true,
            sessionId: event.sessionId,
            totalUrls: result.urls.length,
            sitemapUrls: result.urls,
            nestedSitemaps: result.nestedSitemaps,
            s3Location,
            message: `Successfully parsed sitemap with ${result.urls.length} URLs`,
            processingTime: Date.now() - startTime
        };
    }
    catch (error) {
        console.error('Sitemap parsing failed:', error);
        await progress.error(`Sitemap parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        return {
            success: false,
            sessionId: event.sessionId,
            totalUrls: 0,
            sitemapUrls: [],
            nestedSitemaps: 0,
            s3Location: '',
            message: `Sitemap parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            processingTime: Date.now() - startTime
        };
    }
};
exports.handler = handler;
/**
 * Recursively parse sitemap with nested sitemap support
 * Requirements: 29.1, 29.2, 29.3, 29.7, 29.8, 29.9, 29.10
 */
async function parseSitemapRecursively(sitemapUrl, progress, depth = 0, maxDepth = 3, processedUrls = new Set()) {
    // Prevent infinite recursion and duplicate processing
    if (depth > maxDepth) {
        console.log(`Max depth ${maxDepth} reached, skipping: ${sitemapUrl}`);
        return { urls: [], nestedSitemaps: 0 };
    }
    if (processedUrls.has(sitemapUrl)) {
        console.log(`Already processed: ${sitemapUrl}`);
        return { urls: [], nestedSitemaps: 0 };
    }
    processedUrls.add(sitemapUrl);
    try {
        await progress.progress(`Fetching sitemap: ${sitemapUrl}`, 'sitemap-parsing');
        // Fetch sitemap content with timeout handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        const response = await fetch(sitemapUrl, {
            headers: {
                'User-Agent': 'Lensy Documentation Quality Auditor/1.0'
            },
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const contentType = response.headers.get('content-type') || '';
        let xmlContent;
        // Handle compressed sitemaps
        if (contentType.includes('gzip') || sitemapUrl.endsWith('.gz')) {
            await progress.progress('Decompressing gzipped sitemap...', 'sitemap-parsing');
            // For now, assume uncompressed. In production, would use zlib
            xmlContent = await response.text();
        }
        else {
            xmlContent = await response.text();
        }
        // Parse XML
        const parsedXml = await new Promise((resolve, reject) => {
            (0, xml2js_1.parseString)(xmlContent, {
                explicitArray: true,
                ignoreAttrs: false,
                trim: true
            }, (err, result) => {
                if (err)
                    reject(err);
                else
                    resolve(result);
            });
        });
        let allUrls = [];
        let nestedSitemapCount = 0;
        // Handle sitemap index (contains references to other sitemaps)
        if (parsedXml.sitemapindex?.sitemap) {
            await progress.progress(`Found sitemap index with ${parsedXml.sitemapindex.sitemap.length} nested sitemaps`, 'sitemap-parsing');
            for (const nestedSitemap of parsedXml.sitemapindex.sitemap) {
                if (nestedSitemap.loc && nestedSitemap.loc[0]) {
                    const nestedUrl = nestedSitemap.loc[0].trim();
                    console.log(`Processing nested sitemap: ${nestedUrl}`);
                    const nestedResult = await parseSitemapRecursively(nestedUrl, progress, depth + 1, maxDepth, processedUrls);
                    allUrls.push(...nestedResult.urls);
                    nestedSitemapCount += 1 + nestedResult.nestedSitemaps;
                }
            }
        }
        // Handle regular sitemap (contains actual URLs)
        if (parsedXml.urlset?.url) {
            await progress.progress(`Extracting ${parsedXml.urlset.url.length} URLs from sitemap`, 'sitemap-parsing');
            for (const urlEntry of parsedXml.urlset.url) {
                if (urlEntry.loc && urlEntry.loc[0]) {
                    const url = urlEntry.loc[0].trim();
                    if (url && isValidUrl(url)) {
                        allUrls.push(url);
                    }
                }
            }
        }
        // Remove duplicates
        const uniqueUrls = [...new Set(allUrls)];
        if (depth === 0) {
            await progress.progress(`Sitemap parsing complete: ${uniqueUrls.length} unique URLs found`, 'sitemap-parsing');
        }
        return {
            urls: uniqueUrls,
            nestedSitemaps: nestedSitemapCount
        };
    }
    catch (error) {
        console.error(`Error parsing sitemap ${sitemapUrl}:`, error);
        await progress.error(`Failed to parse sitemap: ${sitemapUrl} - ${error instanceof Error ? error.message : 'Unknown error'}`);
        // Return empty result but don't fail the entire process
        return { urls: [], nestedSitemaps: 0 };
    }
}
/**
 * Validate URL format
 */
function isValidUrl(urlString) {
    try {
        const url = new URL(urlString);
        return url.protocol === 'http:' || url.protocol === 'https:';
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxrREFBZ0U7QUFDaEUsbUNBQXFDO0FBQ3JDLDZEQUF5RDtBQXNDbEQsTUFBTSxPQUFPLEdBQXVELEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRTtJQUN2RixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsT0FBTyxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFbkQsOENBQThDO0lBQzlDLE1BQU0sUUFBUSxHQUFHLElBQUksc0NBQWlCLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3hELE1BQU0sUUFBUSxHQUFHLElBQUksb0JBQVEsQ0FBQyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUM7SUFFbEUsSUFBSTtRQUNBLHdCQUF3QjtRQUN4QixNQUFNLFFBQVEsQ0FBQyxRQUFRLENBQUMsNkJBQTZCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUUxRSw4QkFBOEI7UUFDOUIsTUFBTSxNQUFNLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVyRSxzQkFBc0I7UUFDdEIsTUFBTSxLQUFLLEdBQUcsWUFBWSxLQUFLLENBQUMsU0FBUyx1QkFBdUIsQ0FBQztRQUNqRSxNQUFNLFVBQVUsR0FBRyxRQUFRLE9BQU8sQ0FBQyxHQUFHLENBQUMsZUFBZSxJQUFJLEtBQUssRUFBRSxDQUFDO1FBRWxFLE1BQU0sY0FBYyxHQUFHO1lBQ25CLFdBQVcsRUFBRSxLQUFLLENBQUMsR0FBRztZQUN0QixTQUFTLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNO1lBQzdCLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZ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LENBQUMsQ0FBQyxDQUFDO1FBRXpDLElBQUksS0FBSyxLQUFLLENBQUMsRUFBRTtZQUNiLE1BQU0sUUFBUSxDQUFDLFFBQVEsQ0FBQyw2QkFBNkIsVUFBVSxDQUFDLE1BQU0sb0JBQW9CLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztTQUNsSDtRQUVELE9BQU87WUFDSCxJQUFJLEVBQUUsVUFBVTtZQUNoQixjQUFjLEVBQUUsa0JBQWtCO1NBQ3JDLENBQUM7S0FFTDtJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ1osT0FBTyxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsVUFBVSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDN0QsTUFBTSxRQUFRLENBQUMsS0FBSyxDQUFDLDRCQUE0QixVQUFVLE1BQU0sS0FBSyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztRQUU3SCx3REFBd0Q7UUFDeEQsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLENBQUMsRUFBRSxDQUFDO0tBQzFDO0FBQ0wsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxVQUFVLENBQUMsU0FBaUI7SUFDakMsSUFBSTtRQUNBLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9CLE9BQU8sR0FBRyxDQUFDLFFBQVEsS0FBSyxPQUFPLElBQUksR0FBRyxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUM7S0FDaEU7SUFBQyxNQUFNO1FBQ0osT0FBTyxLQUFLLENBQUM7S0FDaEI7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFuZGxlciB9IGZyb20gJ2F3cy1sYW1iZGEnO1xuaW1wb3J0IHsgUzNDbGllbnQsIFB1dE9iamVjdENvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtczMnO1xuaW1wb3J0IHsgcGFyc2VTdHJpbmcgfSBmcm9tICd4bWwyanMnO1xuaW1wb3J0IHsgUHJvZ3Jlc3NQdWJsaXNoZXIgfSBmcm9tICcuL3Byb2dyZXNzLXB1Ymxpc2hlcic7XG5cbmludGVyZmFjZSBTaXRlbWFwUGFyc2VyRXZlbnQge1xuICAgIHVybDogc3RyaW5nO1xuICAgIHNlc3Npb25JZDogc3RyaW5nO1xuICAgIGlucHV0VHlwZTogJ3NpdGVtYXAnO1xufVxuXG5pbnRlcmZhY2UgU2l0ZW1hcFBhcnNlclJlc3BvbnNlIHtcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIHNlc3Npb25JZDogc3RyaW5nO1xuICAgIHRvdGFsVXJsczogbnVtYmVyO1xuICAgIHNpdGVtYXBVcmxzOiBzdHJpbmdbXTtcbiAgICBuZXN0ZWRTaXRlbWFwczogbnVtYmVyO1xuICAgIHMzTG9jYXRpb246IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgcHJvY2Vzc2luZ1RpbWU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFNpdGVtYXBFbnRyeSB7XG4gICAgbG9jOiBzdHJpbmdbXTtcbiAgICBsYXN0bW9kPzogc3RyaW5nW107XG4gICAgcHJpb3JpdHk/OiBzdHJpbmdbXTtcbiAgICBjaGFuZ2VmcmVxPzogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBQYXJzZWRTaXRlbWFwIHtcbiAgICB1cmxzZXQ/OiB7XG4gICAgICAgIHVybDogU2l0ZW1hcEVudHJ5W107XG4gICAgfTtcbiAgICBzaXRlbWFwaW5kZXg/OiB7XG4gICAgICAgIHNpdGVtYXA6IEFycmF5PHtcbiAgICAgICAgICAgIGxvYzogc3RyaW5nW107XG4gICAgICAgICAgICBsYXN0bW9kPzogc3RyaW5nW107XG4gICAgICAgIH0+O1xuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyOiBIYW5kbGVyPFNpdGVtYXBQYXJzZXJFdmVudCwgU2l0ZW1hcFBhcnNlclJlc3BvbnNlPiA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coJ1BhcnNpbmcgc2l0ZW1hcCBmb3IgVVJMOicsIGV2ZW50LnVybCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHByb2dyZXNzIHB1Ymxpc2hlciBhbmQgUzMgY2xpZW50XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBuZXcgUHJvZ3Jlc3NQdWJsaXNoZXIoZXZlbnQuc2Vzc2lvbklkKTtcbiAgICBjb25zdCBzM0NsaWVudCA9IG5ldyBTM0NsaWVudCh7IHJlZ2lvbjogcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIFNlbmQgaW5pdGlhbCBwcm9ncmVzc1xuICAgICAgICBhd2FpdCBwcm9ncmVzcy5wcm9ncmVzcygnU3RhcnRpbmcgc2l0ZW1hcCBwYXJzaW5nLi4uJywgJ3NpdGVtYXAtcGFyc2luZycpO1xuXG4gICAgICAgIC8vIEZldGNoIGFuZCBwYXJzZSB0aGUgc2l0ZW1hcFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVNpdGVtYXBSZWN1cnNpdmVseShldmVudC51cmwsIHByb2dyZXNzLCAwKTtcblxuICAgICAgICAvLyBTdG9yZSByZXN1bHRzIGluIFMzXG4gICAgICAgIGNvbnN0IHMzS2V5ID0gYHNlc3Npb25zLyR7ZXZlbnQuc2Vzc2lvbklkfS9zaXRlbWFwLXJlc3VsdHMuanNvbmA7XG4gICAgICAgIGNvbnN0IHMzTG9jYXRpb24gPSBgczM6Ly8ke3Byb2Nlc3MuZW52LkFOQUxZU0lTX0JVQ0tFVH0vJHtzM0tleX1gO1xuXG4gICAgICAgIGNvbnN0IHNpdGVtYXBSZXN1bHRzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxVcmw6IGV2ZW50LnVybCxcbiAgICAgICAgICAgIHRvdGFsVXJsczogcmVzdWx0LnVybHMubGVuZ3RoLFxuICAgICAgICAgICAgdXJsczogcmVzdWx0LnVybHMsXG4gICAgICAgICAgICBuZXN0ZWRTaXRlbWFwczogcmVzdWx0Lm5lc3RlZFNpdGVtYXBzLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGF3YWl0IHMzQ2xpZW50LnNlbmQobmV3IFB1dE9iamVjdENvbW1hbmQoe1xuICAgICAgICAgICAgQnVja2V0OiBwcm9jZXNzLmVudi5BTkFMWVNJU19CVUNLRVQsXG4gICAgICAgICAgICBLZXk6IHMzS2V5LFxuICAgICAgICAgICAgQm9keTogSlNPTi5zdHJpbmdpZnkoc2l0ZW1hcFJlc3VsdHMsIG51bGwsIDIpLFxuICAgICAgICAgICAgQ29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gU2VuZCBjb21wbGV0aW9uIG1lc3NhZ2VcbiAgICAgICAgYXdhaXQgcHJvZ3Jlc3Muc3VjY2VzcyhcbiAgICAgICAgICAgIGBTaXRlbWFwIHBhcnNpbmcgY29tcGxldGU6IEZvdW5kICR7cmVzdWx0LnVybHMubGVuZ3RofSBVUkxzJHtyZXN1bHQubmVzdGVkU2l0ZW1hcHMgPiAwID8gYCAoJHtyZXN1bHQubmVzdGVkU2l0ZW1hcHN9IG5lc3RlZCBzaXRlbWFwcylgIDogJyd9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0b3RhbFVybHM6IHJlc3VsdC51cmxzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuZXN0ZWRTaXRlbWFwczogcmVzdWx0Lm5lc3RlZFNpdGVtYXBzLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFNpdGVtYXAgcGFyc2luZyBjb21wbGV0ZWQ6ICR7cmVzdWx0LnVybHMubGVuZ3RofSBVUkxzIGZvdW5kYCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IGV2ZW50LnNlc3Npb25JZCxcbiAgICAgICAgICAgIHRvdGFsVXJsczogcmVzdWx0LnVybHMubGVuZ3RoLFxuICAgICAgICAgICAgc2l0ZW1hcFVybHM6IHJlc3VsdC51cmxzLFxuICAgICAgICAgICAgbmVzdGVkU2l0ZW1hcHM6IHJlc3VsdC5uZXN0ZWRTaXRlbWFwcyxcbiAgICAgICAgICAgIHMzTG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlOiBgU3VjY2Vzc2Z1bGx5IHBhcnNlZCBzaXRlbWFwIHdpdGggJHtyZXN1bHQudXJscy5sZW5ndGh9IFVSTHNgLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpdGVtYXAgcGFyc2luZyBmYWlsZWQ6JywgZXJyb3IpO1xuXG4gICAgICAgIGF3YWl0IHByb2dyZXNzLmVycm9yKGBTaXRlbWFwIHBhcnNpbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIHNlc3Npb25JZDogZXZlbnQuc2Vzc2lvbklkLFxuICAgICAgICAgICAgdG90YWxVcmxzOiAwLFxuICAgICAgICAgICAgc2l0ZW1hcFVybHM6IFtdLFxuICAgICAgICAgICAgbmVzdGVkU2l0ZW1hcHM6IDAsXG4gICAgICAgICAgICBzM0xvY2F0aW9uOiAnJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBTaXRlbWFwIHBhcnNpbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgICBwcm9jZXNzaW5nVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmludGVyZmFjZSBQYXJzZVJlc3VsdCB7XG4gICAgdXJsczogc3RyaW5nW107XG4gICAgbmVzdGVkU2l0ZW1hcHM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBwYXJzZSBzaXRlbWFwIHdpdGggbmVzdGVkIHNpdGVtYXAgc3VwcG9ydFxuICogUmVxdWlyZW1lbnRzOiAyOS4xLCAyOS4yLCAyOS4zLCAyOS43LCAyOS44LCAyOS45LCAyOS4xMFxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZVNpdGVtYXBSZWN1cnNpdmVseShcbiAgICBzaXRlbWFwVXJsOiBzdHJpbmcsXG4gICAgcHJvZ3Jlc3M6IFByb2dyZXNzUHVibGlzaGVyLFxuICAgIGRlcHRoOiBudW1iZXIgPSAwLFxuICAgIG1heERlcHRoOiBudW1iZXIgPSAzLFxuICAgIHByb2Nlc3NlZFVybHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG4pOiBQcm9taXNlPFBhcnNlUmVzdWx0PiB7XG5cbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbiBhbmQgZHVwbGljYXRlIHByb2Nlc3NpbmdcbiAgICBpZiAoZGVwdGggPiBtYXhEZXB0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgTWF4IGRlcHRoICR7bWF4RGVwdGh9IHJlYWNoZWQsIHNraXBwaW5nOiAke3NpdGVtYXBVcmx9YCk7XG4gICAgICAgIHJldHVybiB7IHVybHM6IFtdLCBuZXN0ZWRTaXRlbWFwczogMCB9O1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzZWRVcmxzLmhhcyhzaXRlbWFwVXJsKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWxyZWFkeSBwcm9jZXNzZWQ6ICR7c2l0ZW1hcFVybH1gKTtcbiAgICAgICAgcmV0dXJuIHsgdXJsczogW10sIG5lc3RlZFNpdGVtYXBzOiAwIH07XG4gICAgfVxuXG4gICAgcHJvY2Vzc2VkVXJscy5hZGQoc2l0ZW1hcFVybCk7XG5cbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9ncmVzcy5wcm9ncmVzcyhgRmV0Y2hpbmcgc2l0ZW1hcDogJHtzaXRlbWFwVXJsfWAsICdzaXRlbWFwLXBhcnNpbmcnKTtcblxuICAgICAgICAvLyBGZXRjaCBzaXRlbWFwIGNvbnRlbnQgd2l0aCB0aW1lb3V0IGhhbmRsaW5nXG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAxMDAwMCk7IC8vIDEwIHNlY29uZCB0aW1lb3V0XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzaXRlbWFwVXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTGVuc3kgRG9jdW1lbnRhdGlvbiBRdWFsaXR5IEF1ZGl0b3IvMS4wJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG4gICAgICAgIGxldCB4bWxDb250ZW50OiBzdHJpbmc7XG5cbiAgICAgICAgLy8gSGFuZGxlIGNvbXByZXNzZWQgc2l0ZW1hcHNcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdnemlwJykgfHwgc2l0ZW1hcFVybC5lbmRzV2l0aCgnLmd6JykpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2dyZXNzLnByb2dyZXNzKCdEZWNvbXByZXNzaW5nIGd6aXBwZWQgc2l0ZW1hcC4uLicsICdzaXRlbWFwLXBhcnNpbmcnKTtcbiAgICAgICAgICAgIC8vIEZvciBub3csIGFzc3VtZSB1bmNvbXByZXNzZWQuIEluIHByb2R1Y3Rpb24sIHdvdWxkIHVzZSB6bGliXG4gICAgICAgICAgICB4bWxDb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeG1sQ29udGVudCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIFhNTFxuICAgICAgICBjb25zdCBwYXJzZWRYbWw6IFBhcnNlZFNpdGVtYXAgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBwYXJzZVN0cmluZyh4bWxDb250ZW50LCB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXRBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVBdHRyczogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHJpbTogdHJ1ZVxuICAgICAgICAgICAgfSwgKGVycjogYW55LCByZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBhbGxVcmxzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgbmVzdGVkU2l0ZW1hcENvdW50ID0gMDtcblxuICAgICAgICAvLyBIYW5kbGUgc2l0ZW1hcCBpbmRleCAoY29udGFpbnMgcmVmZXJlbmNlcyB0byBvdGhlciBzaXRlbWFwcylcbiAgICAgICAgaWYgKHBhcnNlZFhtbC5zaXRlbWFwaW5kZXg/LnNpdGVtYXApIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2dyZXNzLnByb2dyZXNzKGBGb3VuZCBzaXRlbWFwIGluZGV4IHdpdGggJHtwYXJzZWRYbWwuc2l0ZW1hcGluZGV4LnNpdGVtYXAubGVuZ3RofSBuZXN0ZWQgc2l0ZW1hcHNgLCAnc2l0ZW1hcC1wYXJzaW5nJyk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkU2l0ZW1hcCBvZiBwYXJzZWRYbWwuc2l0ZW1hcGluZGV4LnNpdGVtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkU2l0ZW1hcC5sb2MgJiYgbmVzdGVkU2l0ZW1hcC5sb2NbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVzdGVkVXJsID0gbmVzdGVkU2l0ZW1hcC5sb2NbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBuZXN0ZWQgc2l0ZW1hcDogJHtuZXN0ZWRVcmx9YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gYXdhaXQgcGFyc2VTaXRlbWFwUmVjdXJzaXZlbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heERlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkVXJsc1xuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFVybHMucHVzaCguLi5uZXN0ZWRSZXN1bHQudXJscyk7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFNpdGVtYXBDb3VudCArPSAxICsgbmVzdGVkUmVzdWx0Lm5lc3RlZFNpdGVtYXBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSByZWd1bGFyIHNpdGVtYXAgKGNvbnRhaW5zIGFjdHVhbCBVUkxzKVxuICAgICAgICBpZiAocGFyc2VkWG1sLnVybHNldD8udXJsKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9ncmVzcy5wcm9ncmVzcyhgRXh0cmFjdGluZyAke3BhcnNlZFhtbC51cmxzZXQudXJsLmxlbmd0aH0gVVJMcyBmcm9tIHNpdGVtYXBgLCAnc2l0ZW1hcC1wYXJzaW5nJyk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgdXJsRW50cnkgb2YgcGFyc2VkWG1sLnVybHNldC51cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsRW50cnkubG9jICYmIHVybEVudHJ5LmxvY1swXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxFbnRyeS5sb2NbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsICYmIGlzVmFsaWRVcmwodXJsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsVXJscy5wdXNoKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICBjb25zdCB1bmlxdWVVcmxzID0gWy4uLm5ldyBTZXQoYWxsVXJscyldO1xuXG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgYXdhaXQgcHJvZ3Jlc3MucHJvZ3Jlc3MoYFNpdGVtYXAgcGFyc2luZyBjb21wbGV0ZTogJHt1bmlxdWVVcmxzLmxlbmd0aH0gdW5pcXVlIFVSTHMgZm91bmRgLCAnc2l0ZW1hcC1wYXJzaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsczogdW5pcXVlVXJscyxcbiAgICAgICAgICAgIG5lc3RlZFNpdGVtYXBzOiBuZXN0ZWRTaXRlbWFwQ291bnRcbiAgICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgc2l0ZW1hcCAke3NpdGVtYXBVcmx9OmAsIGVycm9yKTtcbiAgICAgICAgYXdhaXQgcHJvZ3Jlc3MuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzaXRlbWFwOiAke3NpdGVtYXBVcmx9IC0gJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcblxuICAgICAgICAvLyBSZXR1cm4gZW1wdHkgcmVzdWx0IGJ1dCBkb24ndCBmYWlsIHRoZSBlbnRpcmUgcHJvY2Vzc1xuICAgICAgICByZXR1cm4geyB1cmxzOiBbXSwgbmVzdGVkU2l0ZW1hcHM6IDAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgVVJMIGZvcm1hdFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVXJsKHVybFN0cmluZzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdXJsLnByb3RvY29sID09PSAnaHR0cDonIHx8IHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59Il19