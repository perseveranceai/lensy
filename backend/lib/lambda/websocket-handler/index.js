"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendProgressUpdate = exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const dynamoClient = new client_dynamodb_1.DynamoDBClient({ region: process.env.AWS_REGION || 'us-east-1' });
const docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(dynamoClient);
// Table to store WebSocket connections
const CONNECTIONS_TABLE = process.env.CONNECTIONS_TABLE || 'lensy-websocket-connections';
const handler = async (event) => {
    console.log('WebSocket event:', JSON.stringify(event, null, 2));
    const { connectionId, routeKey, domainName, stage } = event.requestContext;
    try {
        switch (routeKey) {
            case '$connect':
                return await handleConnect(connectionId);
            case '$disconnect':
                return await handleDisconnect(connectionId);
            case 'subscribe':
                return await handleSubscribe(connectionId, event.body);
            default:
                console.log('Unknown route:', routeKey);
                return { statusCode: 400, body: 'Unknown route' };
        }
    }
    catch (error) {
        console.error('WebSocket handler error:', error);
        return {
            statusCode: 500,
            body: JSON.stringify({
                error: 'Internal server error',
                message: error instanceof Error ? error.message : 'Unknown error'
            })
        };
    }
};
exports.handler = handler;
async function handleConnect(connectionId) {
    console.log('Client connected:', connectionId);
    // Store connection in DynamoDB
    await docClient.send(new lib_dynamodb_1.PutCommand({
        TableName: CONNECTIONS_TABLE,
        Item: {
            connectionId,
            connectedAt: Date.now(),
            ttl: Math.floor(Date.now() / 1000) + 3600 // 1 hour TTL
        }
    }));
    return { statusCode: 200, body: 'Connected' };
}
async function handleDisconnect(connectionId) {
    console.log('Client disconnected:', connectionId);
    // Remove connection from DynamoDB
    await docClient.send(new lib_dynamodb_1.DeleteCommand({
        TableName: CONNECTIONS_TABLE,
        Key: { connectionId }
    }));
    return { statusCode: 200, body: 'Disconnected' };
}
async function handleSubscribe(connectionId, body) {
    if (!body) {
        return { statusCode: 400, body: 'Missing body' };
    }
    const { sessionId } = JSON.parse(body);
    if (!sessionId) {
        return { statusCode: 400, body: 'Missing sessionId' };
    }
    console.log(`Subscribing connection ${connectionId} to session ${sessionId}`);
    // Update connection with sessionId
    await docClient.send(new lib_dynamodb_1.PutCommand({
        TableName: CONNECTIONS_TABLE,
        Item: {
            connectionId,
            sessionId,
            connectedAt: Date.now(),
            ttl: Math.floor(Date.now() / 1000) + 3600
        }
    }));
    return { statusCode: 200, body: 'Subscribed' };
}
// Helper function to send progress updates (called by other Lambdas)
async function sendProgressUpdate(sessionId, message, type, metadata) {
    // This function will be imported and used by other Lambda functions
    // to send progress updates to connected WebSocket clients
    console.log(`Progress update for session ${sessionId}:`, message);
    // Implementation will query DynamoDB for connections with this sessionId
    // and send the message to each connection via API Gateway Management API
}
exports.sendProgressUpdate = sendProgressUpdate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9sYW1iZGEvd2Vic29ja2V0LWhhbmRsZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsOERBQTBEO0FBQzFELHdEQUFzRztBQUd0RyxNQUFNLFlBQVksR0FBRyxJQUFJLGdDQUFjLENBQUMsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUksV0FBVyxFQUFFLENBQUMsQ0FBQztBQUMzRixNQUFNLFNBQVMsR0FBRyxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7QUFFNUQsdUNBQXVDO0FBQ3ZDLE1BQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSSw2QkFBNkIsQ0FBQztBQVlsRixNQUFNLE9BQU8sR0FBaUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO0lBQ2pFLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFaEUsTUFBTSxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxHQUFHLEtBQUssQ0FBQyxjQUFjLENBQUM7SUFFM0UsSUFBSTtRQUNBLFFBQVEsUUFBUSxFQUFFO1lBQ2QsS0FBSyxVQUFVO2dCQUNYLE9BQU8sTUFBTSxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDN0MsS0FBSyxhQUFhO2dCQUNkLE9BQU8sTUFBTSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNoRCxLQUFLLFdBQVc7Z0JBQ1osT0FBTyxNQUFNLGVBQWUsQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNEO2dCQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxDQUFDLENB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LFVBQVUsa0JBQWtCLENBQ3BDLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixJQUErQyxFQUMvQyxRQUE4QjtJQUU5QixvRUFBb0U7SUFDcEUsMERBQTBEO0lBQzFELE9BQU8sQ0FBQyxHQUFHLENBQUMsK0JBQStCLFNBQVMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRWxFLHlFQUF5RTtJQUN6RSx5RUFBeUU7QUFDN0UsQ0FBQztBQVpELGdEQVlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFuZGxlciB9IGZyb20gJ2F3cy1sYW1iZGEnO1xuaW1wb3J0IHsgRHluYW1vREJDbGllbnQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtZHluYW1vZGInO1xuaW1wb3J0IHsgRHluYW1vREJEb2N1bWVudENsaWVudCwgUHV0Q29tbWFuZCwgRGVsZXRlQ29tbWFuZCwgR2V0Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2xpYi1keW5hbW9kYic7XG5pbXBvcnQgeyBBcGlHYXRld2F5TWFuYWdlbWVudEFwaUNsaWVudCwgUG9zdFRvQ29ubmVjdGlvbkNvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtYXBpZ2F0ZXdheW1hbmFnZW1lbnRhcGknO1xuXG5jb25zdCBkeW5hbW9DbGllbnQgPSBuZXcgRHluYW1vREJDbGllbnQoeyByZWdpb246IHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHwgJ3VzLWVhc3QtMScgfSk7XG5jb25zdCBkb2NDbGllbnQgPSBEeW5hbW9EQkRvY3VtZW50Q2xpZW50LmZyb20oZHluYW1vQ2xpZW50KTtcblxuLy8gVGFibGUgdG8gc3RvcmUgV2ViU29ja2V0IGNvbm5lY3Rpb25zXG5jb25zdCBDT05ORUNUSU9OU19UQUJMRSA9IHByb2Nlc3MuZW52LkNPTk5FQ1RJT05TX1RBQkxFIHx8ICdsZW5zeS13ZWJzb2NrZXQtY29ubmVjdGlvbnMnO1xuXG5pbnRlcmZhY2UgV2ViU29ja2V0RXZlbnQge1xuICAgIHJlcXVlc3RDb250ZXh0OiB7XG4gICAgICAgIGNvbm5lY3Rpb25JZDogc3RyaW5nO1xuICAgICAgICByb3V0ZUtleTogc3RyaW5nO1xuICAgICAgICBkb21haW5OYW1lOiBzdHJpbmc7XG4gICAgICAgIHN0YWdlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBib2R5Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgaGFuZGxlcjogSGFuZGxlcjxXZWJTb2NrZXRFdmVudCwgYW55PiA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgZXZlbnQ6JywgSlNPTi5zdHJpbmdpZnkoZXZlbnQsIG51bGwsIDIpKTtcblxuICAgIGNvbnN0IHsgY29ubmVjdGlvbklkLCByb3V0ZUtleSwgZG9tYWluTmFtZSwgc3RhZ2UgfSA9IGV2ZW50LnJlcXVlc3RDb250ZXh0O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgc3dpdGNoIChyb3V0ZUtleSkge1xuICAgICAgICAgICAgY2FzZSAnJGNvbm5lY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVDb25uZWN0KGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICBjYXNlICckZGlzY29ubmVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURpc2Nvbm5lY3QoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgIGNhc2UgJ3N1YnNjcmliZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZVN1YnNjcmliZShjb25uZWN0aW9uSWQsIGV2ZW50LmJvZHkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biByb3V0ZTonLCByb3V0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogNDAwLCBib2R5OiAnVW5rbm93biByb3V0ZScgfTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBoYW5kbGVyIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ29ubmVjdChjb25uZWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc29sZS5sb2coJ0NsaWVudCBjb25uZWN0ZWQ6JywgY29ubmVjdGlvbklkKTtcblxuICAgIC8vIFN0b3JlIGNvbm5lY3Rpb24gaW4gRHluYW1vREJcbiAgICBhd2FpdCBkb2NDbGllbnQuc2VuZChuZXcgUHV0Q29tbWFuZCh7XG4gICAgICAgIFRhYmxlTmFtZTogQ09OTkVDVElPTlNfVEFCTEUsXG4gICAgICAgIEl0ZW06IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHRsOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDAgLy8gMSBob3VyIFRUTFxuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogMjAwLCBib2R5OiAnQ29ubmVjdGVkJyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVEaXNjb25uZWN0KGNvbm5lY3Rpb25JZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zb2xlLmxvZygnQ2xpZW50IGRpc2Nvbm5lY3RlZDonLCBjb25uZWN0aW9uSWQpO1xuXG4gICAgLy8gUmVtb3ZlIGNvbm5lY3Rpb24gZnJvbSBEeW5hbW9EQlxuICAgIGF3YWl0IGRvY0NsaWVudC5zZW5kKG5ldyBEZWxldGVDb21tYW5kKHtcbiAgICAgICAgVGFibGVOYW1lOiBDT05ORUNUSU9OU19UQUJMRSxcbiAgICAgICAgS2V5OiB7IGNvbm5lY3Rpb25JZCB9XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZTogMjAwLCBib2R5OiAnRGlzY29ubmVjdGVkJyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTdWJzY3JpYmUoY29ubmVjdGlvbklkOiBzdHJpbmcsIGJvZHk/OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6ICdNaXNzaW5nIGJvZHknIH07XG4gICAgfVxuXG4gICAgY29uc3QgeyBzZXNzaW9uSWQgfSA9IEpTT04ucGFyc2UoYm9keSk7XG5cbiAgICBpZiAoIXNlc3Npb25JZCkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXNDb2RlOiA0MDAsIGJvZHk6ICdNaXNzaW5nIHNlc3Npb25JZCcgfTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgU3Vic2NyaWJpbmcgY29ubmVjdGlvbiAke2Nvbm5lY3Rpb25JZH0gdG8gc2Vzc2lvbiAke3Nlc3Npb25JZH1gKTtcblxuICAgIC8vIFVwZGF0ZSBjb25uZWN0aW9uIHdpdGggc2Vzc2lvbklkXG4gICAgYXdhaXQgZG9jQ2xpZW50LnNlbmQobmV3IFB1dENvbW1hbmQoe1xuICAgICAgICBUYWJsZU5hbWU6IENPTk5FQ1RJT05TX1RBQkxFLFxuICAgICAgICBJdGVtOiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICBjb25uZWN0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR0bDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwXG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByZXR1cm4geyBzdGF0dXNDb2RlOiAyMDAsIGJvZHk6ICdTdWJzY3JpYmVkJyB9O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2VuZCBwcm9ncmVzcyB1cGRhdGVzIChjYWxsZWQgYnkgb3RoZXIgTGFtYmRhcylcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kUHJvZ3Jlc3NVcGRhdGUoXG4gICAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHR5cGU6ICdpbmZvJyB8ICdzdWNjZXNzJyB8ICdlcnJvcicgfCAncHJvZ3Jlc3MnLFxuICAgIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxuKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGltcG9ydGVkIGFuZCB1c2VkIGJ5IG90aGVyIExhbWJkYSBmdW5jdGlvbnNcbiAgICAvLyB0byBzZW5kIHByb2dyZXNzIHVwZGF0ZXMgdG8gY29ubmVjdGVkIFdlYlNvY2tldCBjbGllbnRzXG4gICAgY29uc29sZS5sb2coYFByb2dyZXNzIHVwZGF0ZSBmb3Igc2Vzc2lvbiAke3Nlc3Npb25JZH06YCwgbWVzc2FnZSk7XG5cbiAgICAvLyBJbXBsZW1lbnRhdGlvbiB3aWxsIHF1ZXJ5IER5bmFtb0RCIGZvciBjb25uZWN0aW9ucyB3aXRoIHRoaXMgc2Vzc2lvbklkXG4gICAgLy8gYW5kIHNlbmQgdGhlIG1lc3NhZ2UgdG8gZWFjaCBjb25uZWN0aW9uIHZpYSBBUEkgR2F0ZXdheSBNYW5hZ2VtZW50IEFQSVxufVxuIl19